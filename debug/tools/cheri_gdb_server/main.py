import binascii
import time
import socket
from GDB_RSP_Translator import GDB_RSP_Translator
from RSP_GDB_Translator import RSP_GDB_Translator
from GDB_OpenOCD_Transmitter import GDB_OpenOCD_Transmitter

HOST = "172.29.86.57"
PORT = 3333

if __name__ == '__main__':

    list_of_breakpoints = []
    # If this with statement is exited then the connection is automatically closed
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:

        # Connect to the R-PI that is interfacing with the Core using OpenOCD
        gdb_OpenOCD_transmitter = GDB_OpenOCD_Transmitter(HOST, PORT, s)
        gdb_OpenOCD_transmitter.establish_connection()

        rsp_gdb_translator = RSP_GDB_Translator()
        gdb_rsp_translator = GDB_RSP_Translator(gdb_OpenOCD_transmitter, rsp_gdb_translator)

        # Loop for user to enter commands
        while(1):

            # Sometimes extra packets are generated by GDB
            # Want to make sure that those packets are recieved before
            # performing the next operation
            gdb_OpenOCD_transmitter.flush_out_packet(0.5)

            gdb_command = input("(gdb) ")

            if gdb_command.strip().lower() == "exit" or gdb_command.strip().lower() == "quit":
                print("Exiting GDB")
                exit()

            # Breakdown ""gdb"" command into RSP transferable data
            rsp_command, reg_name, value = gdb_rsp_translator.exact_components_of_gdb_cmd(gdb_command)


            # Write a Single Register
            if rsp_command == "P":
                set_register_command = gdb_rsp_translator.build_rsp_packet(rsp_command, reg_name, value)
                gdb_OpenOCD_transmitter.execute_set_register_command(set_register_command)

            # Write all GPRs
            elif rsp_command == "G":
                set_all_registers_command = gdb_rsp_translator.build_rsp_packet(rsp_command, reg_name, value)
                gdb_OpenOCD_transmitter.execute_set_all_registers_command(set_all_registers_command)

            # Read a Single Register
            elif rsp_command == "p":
                get_register_command = gdb_rsp_translator.build_rsp_packet(rsp_command, reg_name, value)
                register_packet = gdb_OpenOCD_transmitter.execute_get_register_command(get_register_command)

                rsp_gdb_translator.print_register_info_header()
                rsp_gdb_translator.uncompress_and_print_register_data(register_packet, reg_name)

            elif rsp_command == "X":
                address = reg_name
                file_path = value

                try:
                    with open(file_path, "r") as file:
                        for line in file:
                            hex_value = line.strip()  # Remove leading/trailing whitespace and newline characters
                            load_mem_register_command = gdb_rsp_translator.build_rsp_packet(rsp_command, address, hex_value)

                            address = int(address, 16)
                            address += 4
                            address = hex(address)[2:].upper()
                            gdb_OpenOCD_transmitter.execute_load_memory_command(load_mem_register_command)



                except FileNotFoundError:
                    print(f"File not found: {file_path}")
                except Exception as e:
                    print(f"An error occurred: {e}")


            # Read all GPRs
            elif rsp_command == "g":

                print_all_register_command = gdb_rsp_translator.build_rsp_packet(rsp_command, reg_name, value)

                all_register_data = gdb_OpenOCD_transmitter.execute_get_all_registers_command(print_all_register_command)
                rsp_gdb_translator.print_all_registers(all_register_data)

                # Continue the Core
            elif rsp_command == "c":


                stepi_pkt = gdb_rsp_translator.build_rsp_packet("vCont;s:0;c:0", "", "")
                print(stepi_pkt)
                gdb_OpenOCD_transmitter.send_packet_and_receive_ack_stepi(stepi_pkt)

                # Read PC and disable that break point
                for breakpoints in list_of_breakpoints:
                    breakpoint_pkt = gdb_rsp_translator.build_rsp_packet("Z0", "", breakpoints)
                    print(breakpoint_pkt)
                    gdb_OpenOCD_transmitter.send_packet_and_receive_ack_bp(breakpoint_pkt)


                vCont_c_pkt = gdb_rsp_translator.build_rsp_packet("vCont;c", "", "")
                gdb_OpenOCD_transmitter.send_packet_and_receive_ack_con(vCont_c_pkt)


                for breakpoints in list_of_breakpoints:
                    kill_bp_command = gdb_rsp_translator.build_rsp_packet("z0", "", breakpoints)
                    gdb_OpenOCD_transmitter.send_packet_and_receive_ack_bp(kill_bp_command)


                # Continue the Core
            elif rsp_command == "s":
                stepi_pkt = gdb_rsp_translator.build_rsp_packet("vCont;s:0;c:0", "", "")
                gdb_OpenOCD_transmitter.send_packet_and_receive_ack_stepi(stepi_pkt)




            elif rsp_command == "Z0":
                list_of_breakpoints.append(value.replace("0x", ""))

            elif rsp_command == "z0":
                if value.replace("0x", "") in list_of_breakpoints:
                    list_of_breakpoints.remove(value.replace("0x", ""))
                else:
                    print("The breakpoint @ address: " + str(value) + " does not exist!")



            else:
                print("!!!Something Broke!!!")
                exit()

            gdb_OpenOCD_transmitter.send_ack()


